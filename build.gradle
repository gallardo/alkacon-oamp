import org.gradle.api.tasks.testing.logging.TestExceptionFormat
import org.gradle.api.tasks.testing.logging.TestLogEvent

plugins {
    id "com.dorongold.task-tree" version '1.3.1'
    id 'com.gradle.build-scan' version '2.1'
}

buildScan {
    termsOfServiceUrl = 'https://gradle.com/terms-of-service'
    termsOfServiceAgree = 'yes'
}

apply plugin: 'java'
apply plugin: 'maven'

sourceCompatibility = java_target_version
targetCompatibility = java_target_version

buildDir = build_directory
project.ext.currentDate=new Date().format('dd.MM.yy')
project.ext.modulesDistsDir = file("${project.buildDir}/modulesZip")

if (!project.hasProperty('max_heap_size')){
    project.ext.max_heap_size='1024m'
}

repositories {
    if (project.hasProperty('additional_repositories')){
        additional_repositories.split(';').each{ repo ->
            maven { url repo }
            logger.info 'Added additional repo (set in additional_repositories): "' + repo + '"'
        }
    }
    mavenCentral()
    jcenter()
    maven {
        url "http://maven.vaadin.com/vaadin-addons"
    }
}

configurations {
    distribution {
        description = 'libraries included into the opencms distribution'
        transitive = false
    }
    compile {
        description = 'used to compile the modules jars'
        extendsFrom distribution
    }
    gwtCompile {
        description = 'used by the gwt-compiler to compile modules with gwt code'
    }
}

configurations.all {
    transitive = false
}

configurations.testCompile {
    transitive = true
}

configurations.testRuntime {
    transitive = true
}


// import dependencies
apply from: 'dependencies.gradle'

((String)(project.properties['modules_oamp_all'])).split(',').each { String moduleName ->
    sourceSets.create(moduleName,{
        java {
            srcDir "${moduleName}/src"
            exclude '**/test/**'
            exclude '**/client/**'
        }
        resources {
            srcDir "${moduleName}/resources"
        }
    })
    logger.debug 'Created sourceset ' + moduleName + ' -> srcDir = "' + moduleName + '/src"'

    sourceSets[moduleName].compileClasspath = configurations.compile

    String testSourceSetName = "test" + moduleName.capitalize()
    testSourceSetName = testSourceSetName.split('\\.').collect{it.capitalize()}.join().uncapitalize()
    sourceSets.create(testSourceSetName,{
        java {
            srcDirs = ["${moduleName}/test"]
        }
        resources {
            srcDirs = ["${moduleName}/test"]
        }
        compileClasspath += sourceSets[moduleName].compileClasspath
        compileClasspath += sourceSets[moduleName].output
        compileClasspath += configurations.testCompile
        runtimeClasspath += compileClasspath
    })

    logger.debug 'Created sourceset ' + testSourceSetName + ' -> srcDirs = "' + moduleName + '/test"'

    String testTaskName = testSourceSetName
    task "$testTaskName" (type: Test, group: "Verification"){
        description 'Run the ' + moduleName + ' tests.'

        useJUnit()
        include "**/*"
        testClassesDirs = sourceSets[testSourceSetName].output.classesDirs
        classpath = sourceSets[testSourceSetName].runtimeClasspath

        forkEvery = 4
        maxParallelForks = Runtime.runtime.availableProcessors() / 2
    }
    check.dependsOn "$testTaskName"

    // E.g. moduleName = com.alkacon.opencms.v8.calendar
    // E.g. moduleFolder = /home/myuser/src/alkacon-oamp/com.alkacon.opencms.v8.calendar
    File moduleFolder = project.file("${projectDir}/${moduleName}")

    // E.g. srcGwtDir = /home/myuser/src/alkacon-oamp/com.alkacon.opencms.v8.calendar/src
    File srcGwtDir = project.file("${moduleFolder}/src")

    // E.g. manifetsFile = /home/myuser/src/alkacon-oamp/com.alkacon.opencms.v8.calendar/resources/manifest.xml
    File manifestFile = project.file("${moduleFolder}/resources/manifest.xml")
    
    String gwtModule = null
    String gwtSourceSetName = null
    
    // E.g. propertyFile = /home/myuser/src/alkacon-oamp/com.alkacon.opencms.v8.calendar/module.properties
    File propertyFile = project.file("${moduleFolder}/module.properties")
    String gwtRename = null

    if (propertyFile.exists()){
        logger.info "Checking properties for module $moduleName"
        Properties moduleProperties= new Properties()
        moduleProperties.load(new FileInputStream(propertyFile))
        if (moduleProperties['module.gwt']!=null){
            // E.g. gwtModule = com.alkacon.opencms.v8.calendar.SerialDateWidget
            gwtModule = moduleProperties['module.gwt']
            // Convert moduleName to CamelCase following Gradle's default naming conventions for source sets
            gwtSourceSetName = moduleName.split('\\.').collect{it.capitalize()}.join().uncapitalize() + 'Gwt'
            logger.info "Found GWT module $gwtModule"
            def moduleXml = (new XmlParser()).parse(srcGwtDir.toString()+"/" +gwtModule.replaceAll('\\.','/')+'.gwt.xml')
            gwtRename = moduleXml['@rename-to']
            if (gwtRename==null){
                gwtRename=gwtModule
            }
        }
    }
    
    
    def moduleDependencies=[]
    String moduleVersion = version

    if (manifestFile.exists()){
        Node parsedManifest = (new XmlParser()).parse("${moduleFolder}/resources/manifest.xml")
        parsedManifest.module[0].dependencies[0].dependency.each{ dep ->
            moduleDependencies.add(dep.@name)
        }
        moduleVersion = parsedManifest.module[0].version[0].text()
    }
    task "jar_$moduleName" (type: Jar) {
        description "Assembles a jar archive containing the $moduleName classes."
        group "build"

        ext.moduleName = moduleName
        ext.moduleVersion= moduleVersion
        manifest {
            attributes 'Implementation-Title': 'Alkacon OAMP', 'Implementation-Version': moduleVersion
        }
        from sourceSets[moduleName].output
        archiveName moduleName + '.jar'
        baseName moduleName
        exclude '**/.gitignore'
        exclude '**/test/**'
        doFirst {
            println '======================================================'
            println "Building JAR for $moduleName version $moduleVersion"
            println '======================================================'
        }
    }

    task "dist_$moduleName" (dependsOn: "jar_$moduleName", type: Zip){
        description "Creates the OpenCms distributable module $moduleName."
        group "build"

        ext.moduleName = moduleName
        ext.moduleFolder = moduleFolder
        ext.dependencies = moduleDependencies
        ext.gwtSourceSetName = gwtSourceSetName
        ext.gwtRenameTo = gwtRename
        if (project.hasProperty('noVersion')) {
        	version 
        } else {
         	version moduleVersion
        }
        destinationDir modulesDistsDir
        // include the jar file
        from( "${project.buildDir}/libs") {
            include "${moduleName}.jar"
            into "/system/modules/${moduleName}/lib/"
        }
        baseName moduleName
        doFirst {
            println '======================================================'
            println "Building ZIP for $moduleName version $moduleVersion"
            println '======================================================'
        }
        // include the GWT resources if necessary
        if (gwtModule == null) {
            from "${moduleFolder}/resources"
        } else {
            // exclude the manifest for now, use the synced manifest later
            from ("${moduleFolder}/resources") {
                exclude 'manifest.xml'
                exclude "system/modules/${moduleName}/resources/${gwtRenameTo}/**"
            }
            from( "${project.buildDir}/gwt/${moduleName}") {
                exclude '**/WEB-INF/**'
                into "/system/modules/${moduleName}/resources/"
            }
            def syncedManifest="${project.buildDir}/extra/${moduleName}/manifest.xml"
            from syncedManifest
            doFirst{
                logger.info "Syncing manifest from ${moduleFolder}/resources/manifest.xml to ${syncedManifest} using resources folder system/modules/${moduleName}/resources/${gwtRenameTo} with resources from ${project.buildDir}/gwt/${moduleName}/${gwtRenameTo}" 
                ant.taskdef(resource: 'org/opencms/util/ant/taskdefs.properties', classpath: configurations.compile.asPath)
                ant.syncmanifest(
                        srcmanifestfile: "${moduleFolder}/resources/manifest.xml",
                        dstmanifestfile: syncedManifest,
                        base: "${moduleFolder}/resources/",
                        prefix: "system/modules/${moduleName}/resources/${gwtRenameTo}",
                        directory: "${project.buildDir}/gwt/${moduleName}/${gwtRenameTo}"
                        )
            }
        }
    }

    // E.g. gwtModule = com.alkacon.opencms.v8.calendar.SerialDateWidget
    if (gwtModule != null){
        sourceSets.create(gwtSourceSetName,{
            java {
                srcDirs srcGwtDir
                exclude '**/test/**'
            }
            resources {
                srcDirs srcGwtDir
            }
        })
        logger.debug 'Created sourceset ' + gwtSourceSetName + ' for GWT module "' + gwtModule + '" -> srcDirs = "' + srcGwtDir + '"'

        configurations {
            "${gwtSourceSetName}Compile" {
                description = "gwt-compiler classpath for $gwtSourceSetName"

                // Used during the javac-compilation
                extendsFrom compile
                // Used during the gwt-compilation
                extendsFrom gwtCompile
            }
        }

        task "gwt_$moduleName" (dependsOn: "${gwtSourceSetName}Classes", type: JavaExec) {
            description = "Invokes the GWT Compiler to create the GWT module $moduleName."
            group = "gwt"

            ext.buildDir =  project.buildDir.toString()  +"/gwt/$moduleName"
            ext.extraDir =  project.buildDir.toString() + "/extra/$moduleName"
            ext.moduleName = moduleName
            inputs.files sourceSets[gwtSourceSetName].java.srcDirs
            inputs.dir sourceSets[gwtSourceSetName].output.resourcesDir
            outputs.dir buildDir

            doFirst {
                println '======================================================'
                println "Building GWT resources for $gwtModule"
                println '======================================================'
                // to clean the output directory, delete it first
                def dir = file(buildDir)
                if (dir.exists()){
                    delete dir
                }
                dir.mkdirs()
            }

            main = 'com.google.gwt.dev.Compiler'

            classpath {
                [
                    // Classpath with the gwt-compiler
                    configurations.gwtCompile,
                    sourceSets[moduleName].java.srcDirs,
                    sourceSets[moduleName].compileClasspath,
                    sourceSets[gwtSourceSetName].java.srcDirs,
                    sourceSets[gwtSourceSetName].output.resourcesDir,
                    sourceSets[gwtSourceSetName].output.classesDirs
                ]
            }

            args =
                    [
                        gwtModule,
                        // Your GWT module
                        '-war',
                        buildDir,
                        '-logLevel',
                        'INFO',
                        '-localWorkers',
                        '2',
                        '-style',
                        'PRETTY',
                        '-extra',
                        extraDir,
                        '-strict',
                        '-failOnError',
                        '-draftCompile' // Speeds up compile with 25%
                    ]

            maxHeapSize = max_heap_size
        }

        tasks["dist_$moduleName"].dependsOn tasks["gwt_$moduleName"]
    }
    
    task "javadoc_$moduleName" (type: Javadoc, group: 'Documentation'){
        description "Generates Javadoc API documentation for the $moduleName source code."

        source = sourceSets[moduleName].allJava
        classpath = project.sourceSets[moduleName].compileClasspath
        destinationDir = file("${buildDir}/docs/javadoc${moduleName}")
        options.addStringOption("sourcepath", "")
    }

    task "jarJavadoc_$moduleName" (type: Jar, group: 'build') {
        description "Assembles a jar archive with the Javadoc API documentation for the $moduleName source code."

        it.dependsOn("javadoc_$moduleName")
        classifier = 'javadoc'
        from "${buildDir}/docs/javadoc${moduleName}"
        baseName moduleName
    }

    task "jarSources_$moduleName" (type: Jar, group: 'Build') {
        description "Assembles a jar archive containing the $moduleName source code."
        from sourceSets[moduleName].allSource
        classifier = 'sources'
        baseName moduleName
    }
    
}

task bindist {
    description "Builds all distributables."
    group "build"

    doFirst{
        println 'Done'
    }
}

tasks.findAll { Task task -> task.name.startsWith('dist_') }.each { Task distTask ->
    distTask.dependencies.each { String dep ->
        String depCompileName = 'compile' + dep.replaceAll('\\.', '') + 'java'

        // TODO: AG 2019-01-30 - There is a SourceSet.getCompileTaskName and SourceSet.getTaskName that could be used for this
        // Eg.: sourceSets[distTask.moduleName].getCompileTaskName
        tasks.findAll { Task compTask -> (compTask.name.toLowerCase() == depCompileName) }.each { Task compTask ->
            sourceSets[distTask.moduleName].compileClasspath += compTask.outputs.files

            if (distTask.gwtSourceSetName != null) {
                sourceSets[distTask.gwtSourceSetName].compileClasspath += compTask.outputs.files

                // We need to manipulate the classpath of the java doc task specifically
                tasks['javadoc_' + distTask.moduleName].classpath += compTask.outputs.files
            }
        }
    }

    // TODO: AG 2019-01-30 - There is a SourceSet.getCompileTaskName and SourceSet.getTaskName that could be used for this
    // Eg.: sourceSets[distTask.moduleName].getCompileTaskName
    tasks['jar_' + distTask.moduleName].dependsOn {
        tasks.findAll { Task compTask -> (compTask.name.toLowerCase() == 'compile' + distTask.moduleName.replaceAll('\\.', '') + 'java') }
    }
    bindist.dependsOn distTask
}

artifacts {
    tasks.each{ Task task ->
        if (task.name.startsWith("jar_com.alkacon.")) {
            String moduleName = task.baseName
            archives task
            archives tasks["jarJavadoc_$moduleName"]
            archives tasks["jarSources_$moduleName"]
        }
    }
}

install {
    repositories {
        mavenInstaller {
            artifacts.each{ arch ->
                def filterName=arch.name
                if (filterName.startsWith("com.alkacon")){
                    filterName=filterName.substring(0, filterName.lastIndexOf(".jar"))
                    addFilter(filterName){artifact, file ->
                        artifact.name.startsWith(filterName)
                    }
                    pom(filterName).project {
                        name 'Alkacon OAMP'
                        description 'Alkacon OAMP'
                        packaging 'jar'
                        groupId 'com.alkacon'
                        url 'http://www.alkacon.com'
                        scm {
                            url 'scm:git@github.com:alkacon/alkacon-oamp.git'
                            connection 'scm:git@github.com:alkacon/alkacon-oamp.git'
                            developerConnection 'scm:git@github.com:alkacon/alkacon-oamp.git'
                        }
                        licenses {
                            license {
                                name 'GNU General Public License'
                                url 'http://www.gnu.org/licenses/gpl.html'
                                distribution 'repo'
                            }
                        }
                        organization {
                            name 'Alkacon Software'
                            url 'http://www.alkacon.com'
                        }
                        developers {
                            developer {
                                name 'Alkacon Software'
                                url 'http://www.alkacon.com'
                            }
                        }
                    }
                }
            }
        }
    }
}

// fixed issue with libraries containing both .java and .class files
compileJava {
    options.compilerArgs += ["-sourcepath", ""]
    options.encoding='UTF-8'
}

tasks.withType(Javadoc) {
    options.addStringOption("sourcepath", "")
    if (JavaVersion.current().isJava8Compatible()) {
        options.addStringOption("Xdoclint:none", "-quiet")
        options.addBooleanOption("-allow-script-in-comments",true);
    }
}

// all tasks implementing the CopySpec (Copy,Jar,Zip,...) should fail, in case they generate duplicate files
tasks.withType(CopySpec){
//    duplicatesStrategy 'fail'
}

// Enrich tests execution output [From https://stackoverflow.com/a/36130467/413020]
tasks.withType(Test) {
    testLogging {
        // set options for log level LIFECYCLE
        events TestLogEvent.FAILED,
                TestLogEvent.PASSED,
                TestLogEvent.SKIPPED,
                TestLogEvent.STANDARD_OUT
        exceptionFormat TestExceptionFormat.FULL
        showExceptions true
        showCauses true
        showStackTraces true

        // set options for log level DEBUG and INFO
        debug {
            events TestLogEvent.STARTED,
                    TestLogEvent.FAILED,
                    TestLogEvent.PASSED,
                    TestLogEvent.SKIPPED,
                    TestLogEvent.STANDARD_ERROR,
                    TestLogEvent.STANDARD_OUT
            exceptionFormat TestExceptionFormat.FULL
        }
        info.events = debug.events
        info.exceptionFormat = debug.exceptionFormat

        afterSuite { desc, result ->
            if (!desc.parent) { // will match the outermost suite
                def output = "Results: ${result.resultType} (${result.testCount} tests, ${result.successfulTestCount} successes, ${result.failedTestCount} failures, ${result.skippedTestCount} skipped)"
                def startItem = '|  ', endItem = '  |'
                def repeatLength = startItem.length() + output.length() + endItem.length()
                println('\n' + ('-' * repeatLength) + '\n' + startItem + output + endItem + '\n' + ('-' * repeatLength))
            }
        }
    }
}